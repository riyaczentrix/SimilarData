import pandas as pd
import re
import numpy as np # For handling NaN values

# --- Configuration ---
FILE_NAME = 'fulldata.csv' # Your input CSV file
PROBLEM_COLUMN = 'problem_reported' # Name of the problem reported column - **CHECK THIS NAME IN YOUR CSV!**
MAIL_BODY_COLUMN = 'DecodedBody' # Name of the mail body column
CLEANED_OUTPUT_FILE = 'temp_file.csv' # Output file for cleaned data

# --- Pre-compile regex patterns for performance ---

# Rule 3 specific block (normalized and lowercased for direct string 'in' check)
_SPECIFIC_BLOCK_RAW = r"""
b'\n\n \n \n \n\n\n \nInternal \n \n \n \n \n Dear Ravi, \n \n Kindly extend your support to share the Not Dialed reason for below list. Be noted these numbers were uploaded 4 times on 9th Feb\x9224 but was not dialed at all. If it was rescheduled, I need the id with which it rescheduled.\n \n \n \n \n \n \n Not Dialed \n \n \n \n \n 599075055 \n \n \n \n \n 553575999 \n \n \n \n \n 500700044 \n \n \n \n \n 535216630 \n \n \n \n \n 555234049 \n \n \n \n \n 539999495 \n \n \n \n \n 567582101 \n \n \n \n \n 533855394 \n \n \n \n \n 503882099 \n \n \n \n \n 574290175 \n \n \n \n \n 549344233 \n \n \n \n \n 535054455 \n \n \n \n \n 555594490 \n \n \n \n \n 557908696 \n \n \n \n \n 599798668 \n \n \n \n \n 594999991 \n \n \n \n \n 566212252 \n \n \n \n \n 569744688 \n \n \n \n \n 508021971 \n \n \n \n \n 533783672 \n \n \n \n \n 509374590 \n \n \n \n \n 503393098 \n \n \n \n \n 530660812 \n \n \n \n \n 505944473 \n \n \n \n \n 555593243 \n \n \n \n \n 591794555 \n \n \n \n \n 544501684 \n \n \n \n \n 555302289 \n \n \n \n \n 564637219 \n \n \n \n \n 530805808 \n \n
"""
_SPECIFIC_BLOCK_NORMALIZED = re.sub(r'\s+', ' ', _SPECIFIC_BLOCK_RAW).strip().lower()

# Rule 4: 'Reply above this line'
_REPLY_PATTERN = re.compile(r'(?i)(?:^|[\W_]+)Reply above this line')

# Rule 6 (second part): 'This message was created automatically by mail delivery software.'
_AUTO_MAIL_DELIVERY_PATTERN = re.compile(r'this message was created automatically by mail delivery software', re.IGNORECASE)

# Rule 2: Insert newline before keywords
_INSERT_NEWLINE_KEYWORDS = [
    r'Thanks & Regard',
    r'Best Regards',
    r'Regards,?', # Matches "Regards" and "Regards,"
    r'Thanks',
    r'Thank'
]
_COMBINED_INSERT_NEWLINE_PATTERN = re.compile(r'(?i)\b(' + '|'.join(_INSERT_NEWLINE_KEYWORDS) + r')')

# Whitespace normalization patterns
_MULTIPLE_SPACES_TABS = re.compile(r'[ \t]+')
_MULTIPLE_NEWLINES = re.compile(r'\n+')
_SPACES_AROUND_NEWLINES = re.compile(r' ?\n ?')


# --- Cleaning Functions ---

def clean_problem_reported_entry(problem_text):
    """
    Cleans a single problem reported entry based on specified rules.
    Returns None if the entry should be removed, otherwise returns the cleaned text.
    """
    if pd.isna(problem_text) or not str(problem_text).strip():
        return None # Remove if NaN or empty/whitespace

    text = str(problem_text).strip()

    # Rule 1: Remove if starts with 're', 'fwd:', 'fw' (case insensitive)
    if re.match(r'^(re|fwd:|fw)\s*:', text, re.IGNORECASE):
        return None

    # Rule 5: Remove if contains 'Mail Delivery Failure' or 'Mail delivery failed' (case insensitive)
    if re.search(r'mail delivery failure|mail delivery failed', text, re.IGNORECASE):
        return None

    # Rule 6 (first part): Remove if contains 'Undeliverable' (case insensitive)
    if re.search(r'undeliverable', text, re.IGNORECASE):
        return None

    # Rule 7: Remove if contains 'Resolved', 'Warning', 'Disaster', 'High' (case insensitive)
    if re.search(r'resolved|warning|disaster|high', text, re.IGNORECASE):
        return None
    
    return text # Return original text if no removal rule matched

def clean_decoded_body_entry(body_text):
    """
    Cleans a single decoded body entry based on specified rules.
    Returns None if the entry should be removed, otherwise returns the cleaned text.
    """
    if pd.isna(body_text) or not str(body_text).strip():
        return None # Remove if NaN or empty/whitespace

    text = str(body_text) # Keep original casing and punctuation for splitting/matching

    # --- Apply removal rules first ---
    # Rule 3: Remove if contains the specific large block of text (case insensitive, ignoring whitespace)
    # Normalize the current text for comparison with the pre-normalized specific block
    normalized_current_text_for_comparison = _MULTIPLE_SPACES_TABS.sub(' ', text).strip().lower()
    if _SPECIFIC_BLOCK_NORMALIZED in normalized_current_text_for_comparison:
        return None # Remove the entire row if this block is found

    # Rule 4: Remove if contains 'Reply above this line' patterns (case insensitive)
    if _REPLY_PATTERN.search(text):
        return None

    # Rule 6 (second part): Remove if contains 'This message was created automatically by mail delivery software.' (case insensitive)
    if _AUTO_MAIL_DELIVERY_PATTERN.search(text):
        return None

    # --- Apply formatting rules if no removal occurred ---

    # Rule 2: Insert newline before 'Regards', 'Thanks & Regard', etc.
    text_with_inserted_newlines = _COMBINED_INSERT_NEWLINE_PATTERN.sub(r'\n\1', text)
    
    # Normalize all whitespace:
    cleaned_text = _MULTIPLE_SPACES_TABS.sub(' ', text_with_inserted_newlines)
    cleaned_text = _MULTIPLE_NEWLINES.sub('\n', cleaned_text)
    cleaned_text = _SPACES_AROUND_NEWLINES.sub('\n', cleaned_text)
    
    # Finally, strip leading/trailing whitespace from the whole string
    cleaned_text = cleaned_text.strip()

    return cleaned_text

# --- Load the dataset from CSV ---
try:
    df = pd.read_csv(FILE_NAME, encoding='mac_roman')
    print(f"Successfully loaded '{FILE_NAME}'.")
    print(f"Total rows in raw DataFrame: {len(df)}")
    print("\n--- Head of RAW DataFrame before cleaning ---")
    print(df.head())
except FileNotFoundError:
    print(f"Error: '{FILE_NAME}' not found. Please ensure the file is in the same directory as the script.")
    exit()
except UnicodeDecodeError as e:
    print(f"Error: Could not decode the file with 'mac_roman' encoding. Please check the file encoding or try another one. Details: {e}")
    print("Common encodings to try: 'utf-8', 'latin1', 'cp1252'")
    exit()
except Exception as e:
    print(f"An error occurred while loading the CSV file: {e}")
    exit()

# Ensure required columns exist
required_columns = [MAIL_BODY_COLUMN, PROBLEM_COLUMN]
for col in required_columns:
    if col not in df.columns:
        print(f"Error: Column '{col}' not found in '{FILE_NAME}'. Please check the column name.")
        print(f"Available columns are: {df.columns.tolist()}") # This line will now print available columns
        exit()

# --- Apply Cleaning ---
print("\nApplying cleaning rules...")

# Create a copy to store cleaned data and avoid modifying original df directly during iteration
cleaned_df = df.copy()

# Apply cleaning for Problem Reported column
# Use .apply and then filter rows where the result is None
cleaned_df['temp_problem_reported'] = cleaned_df[PROBLEM_COLUMN].apply(clean_problem_reported_entry)
cleaned_df = cleaned_df.dropna(subset=['temp_problem_reported']) # Drop rows where problem_reported became None
cleaned_df[PROBLEM_COLUMN] = cleaned_df['temp_problem_reported'] # Update the column
cleaned_df = cleaned_df.drop(columns=['temp_problem_reported']) # Remove temp column

# Apply cleaning for DecodedBody column
# Create DecodedBody_cleaned column
cleaned_df['DecodedBody_cleaned'] = cleaned_df[MAIL_BODY_COLUMN].apply(clean_decoded_body_entry)
# Drop rows where DecodedBody_cleaned became None
cleaned_df = cleaned_df.dropna(subset=['DecodedBody_cleaned'])

print(f"Cleaning complete. Remaining rows: {len(cleaned_df)}")

# --- Display the first few rows of the cleaned DataFrame ---
print(f"\n--- Head of Cleaned DataFrame ({CLEANED_OUTPUT_FILE}) ---")
print(cleaned_df.head())

# --- Save the cleaned DataFrame to a new CSV file ---
print(f"\nSaving cleaned DataFrame to '{CLEANED_OUTPUT_FILE}'...")
cleaned_df.to_csv(CLEANED_OUTPUT_FILE, index=False)
print(f"Cleaned data saved to '{CLEANED_OUTPUT_FILE}'.")

