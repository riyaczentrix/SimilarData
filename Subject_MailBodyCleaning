import pandas as pd
import re
import numpy as np # For handling NaN values

# --- Configuration ---
FILE_NAME = 'fulldata.csv' # Your input CSV file
PROBLEM_COLUMN = 'problem_reported' # Name of the problem reported column - **CHECK THIS NAME IN YOUR CSV!**
MAIL_BODY_COLUMN = 'DecodedBody' # Name of the mail body column
CLEANED_OUTPUT_FILE = 'temp_file.csv' # Output file for cleaned data

# --- Cleaning Functions ---

def clean_problem_reported_entry(problem_text):
    """
    Cleans a single problem reported entry based on specified rules.
    Returns None if the entry should be removed, otherwise returns the cleaned text.
    """
    if pd.isna(problem_text) or not str(problem_text).strip():
        return None # Remove if NaN or empty/whitespace

    text = str(problem_text).strip()

    # Rule 1: Remove if starts with 're', 'fwd:', 'fw' (case insensitive)
    if re.match(r'^(re|fwd:|fw)\s*:', text, re.IGNORECASE):
        return None

    # Rule 5: Remove if contains 'Mail Delivery Failure' or 'Mail delivery failed' (case insensitive)
    if re.search(r'mail delivery failure|mail delivery failed', text, re.IGNORECASE):
        return None

    # Rule 6 (first part): Remove if contains 'Undeliverable' (case insensitive)
    if re.search(r'undeliverable', text, re.IGNORECASE):
        return None

    # Rule 7: Remove if contains 'Resolved', 'Warning', 'Disaster', 'High' (case insensitive)
    if re.search(r'resolved|warning|disaster|high', text, re.IGNORECASE):
        return None
    
    return text # Return original text if no removal rule matched

def clean_decoded_body_entry(body_text):
    """
    Cleans a single decoded body entry based on specified rules.
    Returns None if the entry should be removed, otherwise returns the cleaned text.
    """
    if pd.isna(body_text) or not str(body_text).strip():
        return None # Remove if NaN or empty/whitespace

    text = str(body_text) # Keep original casing and punctuation for splitting/matching

    # --- Apply removal rules first ---
    # Rule 3: Remove if contains the specific large block of text (case insensitive, ignoring whitespace)
    specific_block = r"""
    b'\n\n \n \n \n\n\n \nInternal \n \n \n \n \n Dear Ravi, \n \n Kindly extend your support to share the Not Dialed reason for below list. Be noted these numbers were uploaded 4 times on 9th Feb\x9224 but was not dialed at all. If it was rescheduled, I need the id with which it rescheduled.\n \n \n \n \n \n \n Not Dialed \n \n \n \n \n 599075055 \n \n \n \n \n 553575999 \n \n \n \n \n 500700044 \n \n \n \n \n 535216630 \n \n \n \n \n 555234049 \n \n \n \n \n 539999495 \n \n \n \n \n 567582101 \n \n \n \n \n 533855394 \n \n \n \n \n 503882099 \n \n \n \n \n 574290175 \n \n \n \n \n 549344233 \n \n \n \n \n 535054455 \n \n \n \n \n 555594490 \n \n \n \n \n 557908696 \n \n \n \n \n 599798668 \n \n \n \n \n 594999991 \n \n \n \n \n 566212252 \n \n \n \n \n 569744688 \n \n \n \n \n 508021971 \n \n \n \n \n 533783672 \n \n \n \n \n 509374590 \n \n \n \n \n 503393098 \n \n \n \n \n 530660812 \n \n \n \n \n 505944473 \n \n \n \n \n 555593243 \n \n \n \n \n 591794555 \n \n \n \n \n 544501684 \n \n \n \n \n 555302289 \n \n \n \n \n 564637219 \n \n \n \n \n 530805808 \n \n
    """
    normalized_block = re.sub(r'\s+', ' ', specific_block).strip().lower()
    if normalized_block in re.sub(r'\s+', ' ', text).strip().lower():
        return None # Remove the entire row if this block is found

    # Rule 4: Remove if contains 'Reply above this line' patterns (case insensitive)
    reply_patterns = r'^-+\s*Reply above this line\s*|^Reply above this line'
    if re.search(reply_patterns, text, re.IGNORECASE):
        return None

    # Rule 6 (second part): Remove if contains 'This message was created automatically by mail delivery software.' (case insensitive)
    if re.search(r'this message was created automatically by mail delivery software', text, re.IGNORECASE):
        return None

    # --- Apply formatting rules if no removal occurred ---

    # Rule 2: Insert newline before 'Regards', 'Thanks & Regard', etc.
    insert_newline_patterns = [
        r'Thanks & Regard',
        r'Best Regards',
        r'Regards,?', # Matches "Regards" and "Regards,"
        r'Thanks',
        r'Thank'
    ]
    # Create a single regex pattern for all keywords, ensuring word boundaries where appropriate
    # (?i) for case-insensitive matching
    combined_pattern = r'(?i)\b(' + '|'.join(insert_newline_patterns) + r')'
    
    # Insert newline BEFORE the matched keyword
    text_with_inserted_newlines = re.sub(combined_pattern, r'\n\1', text)
    
    # Normalize all whitespace:
    # 1. Replace multiple spaces/tabs with a single space.
    cleaned_text = re.sub(r'[ \t]+', ' ', text_with_inserted_newlines)
    
    # 2. Replace multiple newlines with a single newline.
    cleaned_text = re.sub(r'\n+', '\n', cleaned_text)

    # 3. Remove spaces that are directly adjacent to newlines (e.g., "word \n word" -> "word\nword")
    cleaned_text = re.sub(r' ?\n ?', '\n', cleaned_text)
    
    # Finally, strip leading/trailing whitespace from the whole string
    cleaned_text = cleaned_text.strip()

    return cleaned_text

# --- Load the dataset from CSV ---
try:
    df = pd.read_csv(FILE_NAME, encoding='mac_roman')
    print(f"Successfully loaded '{FILE_NAME}'.")
    print(f"Total rows in raw DataFrame: {len(df)}")
    print("\n--- Head of RAW DataFrame before cleaning ---")
    print(df.head())
except FileNotFoundError:
    print(f"Error: '{FILE_NAME}' not found. Please ensure the file is in the same directory as the script.")
    exit()
except UnicodeDecodeError as e:
    print(f"Error: Could not decode the file with 'mac_roman' encoding. Please check the file encoding or try another one. Details: {e}")
    print("Common encodings to try: 'utf-8', 'latin1', 'cp1252'")
    exit()
except Exception as e:
    print(f"An error occurred while loading the CSV file: {e}")
    exit()

# Ensure required columns exist
required_columns = [MAIL_BODY_COLUMN, PROBLEM_COLUMN]
for col in required_columns:
    if col not in df.columns:
        print(f"Error: Column '{col}' not found in '{FILE_NAME}'. Please check the column name.")
        print(f"Available columns are: {df.columns.tolist()}") # This line will now print available columns
        exit()

# --- Apply Cleaning ---
print("\nApplying cleaning rules...")

# Create a copy to store cleaned data and avoid modifying original df directly during iteration
cleaned_df = df.copy()

# Apply cleaning for Problem Reported column
# Use .apply and then filter rows where the result is None
cleaned_df['temp_problem_reported'] = cleaned_df[PROBLEM_COLUMN].apply(clean_problem_reported_entry)
cleaned_df = cleaned_df.dropna(subset=['temp_problem_reported']) # Drop rows where problem_reported became None
cleaned_df[PROBLEM_COLUMN] = cleaned_df['temp_problem_reported'] # Update the column
cleaned_df = cleaned_df.drop(columns=['temp_problem_reported']) # Remove temp column

# Apply cleaning for DecodedBody column
# Create DecodedBody_cleaned column
cleaned_df['DecodedBody_cleaned'] = cleaned_df[MAIL_BODY_COLUMN].apply(clean_decoded_body_entry)
# Drop rows where DecodedBody_cleaned became None
cleaned_df = cleaned_df.dropna(subset=['DecodedBody_cleaned'])

print(f"Cleaning complete. Remaining rows: {len(cleaned_df)}")

# --- Display the first few rows of the cleaned DataFrame ---
print(f"\n--- Head of Cleaned DataFrame ({CLEANED_OUTPUT_FILE}) ---")
print(cleaned_df.head())

# --- Save the cleaned DataFrame to a new CSV file ---
print(f"\nSaving cleaned DataFrame to '{CLEANED_OUTPUT_FILE}'...")
cleaned_df.to_csv(CLEANED_OUTPUT_FILE, index=False)
print(f"Cleaned data saved to '{CLEANED_OUTPUT_FILE}'.")
